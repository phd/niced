#!/usr/bin/python3

SCAN_WHOLE_TREE_DELAY = '5'
CONFIG_PATH = './nicedrc'

import psutil
import re
import signal
import subprocess
import sys
import threading
import time

def sig_exit(sig, frame):
    print("Exiting...")
    sys.exit(0)

signal.signal(signal.SIGINT,  sig_exit)
signal.signal(signal.SIGTERM, sig_exit)
signal.signal(signal.SIGCONT, sig_exit)

lock = threading.Lock()

class ConfigRule():
    regex         = None
    compiled      = None
    nice          = None
    io_realtime   = None
    io_besteffort = None
    io_idle       = None
    oom           = None

class Config(object):
    rules                 = []
    scan_whole_tree_delay = SCAN_WHOLE_TREE_DELAY
    def read(self):
        with open(CONFIG_PATH, 'r') as config_file:
            for line in config_file:
                line = line.strip()
                if (line[0] == '#'):
                    continue
                if (line[0] == '@'):
                    line = line[1:]
                    items = re.split('\s*=\s*', line)
                    setattr(config, items[0], items[1])
                line = re.sub('\s+', ' ', line)
                items = line.split(' ')
                rule = ConfigRule()
                rule.regex = items[1]
                if (not rule.regex.startswith('(')):
                    rule.regex = '(^|[^\s]*/)(' + rule.regex + ')(\s|$)'
                rule.compiled = re.compile(rule.regex)
                config.rules.append(rule)
config = Config()

class ProcessEntry(object):
    pid     = None
    command = None
    def __init__(self, pid = None, command = None):
        self.pid     = pid
        self.command = command
    def __str__(self):
        return "ProcessEntry(\n" + \
            "         pid={}\n".format(self.pid    ) + \
            "     command={}\n".format(self.command) + \
            ")"

class ForkstatEntry(object):
    time     = None
    event    = None
    pid      = None
    uid      = None
    euid     = None
    tty      = None
    info     = None
    duration = None
    command  = None
    def __str__(self):
        return "ForkstatEntry(\n" + \
            "        time={}\n".format(self.time    ) + \
            "       event={}\n".format(self.event   ) + \
            "         pid={}\n".format(self.pid     ) + \
            "         uid={}\n".format(self.uid     ) + \
            "        euid={}\n".format(self.euid    ) + \
            "         tty={}\n".format(self.tty     ) + \
            "        info={}\n".format(self.info    ) + \
            "    duration={}\n".format(self.duration) + \
            "     command={}\n".format(self.command ) + \
            ")"

def scan_whole_tree():
    while (True):
        lock.acquire()
        for process in psutil.process_iter():
            processEntry = ProcessEntry()
            processEntry.pid     = process.pid
            processEntry.command = ' '.join(process.cmdline())
            if (processEntry.pid and processEntry.command):
                process_process_entry(processEntry)
        lock.release()
        time.sleep(int(config.scan_whole_tree_delay))

def process_forkstat_line(line):
    lock.acquire()
    line = re.sub('\s+', ' ', line)
    items = line.split(' ')
    if (re.match('[0-9]+:[0-9]+:[0-9]+', items[0])):
        process = False;
        forkstatEntry = ForkstatEntry()
        forkstatEntry.time  = items[0]
        forkstatEntry.event = items[1]
        forkstatEntry.pid   = items[2]
        forkstatEntry.uid   = items[3]
        forkstatEntry.euid  = items[4]
        forkstatEntry.tty   = items[5]
        match (forkstatEntry.event):
            case 'clone':
                forkstatEntry.info     = items[6]
                forkstatEntry.duration = None
                forkstatEntry.command  = ' '.join(items[7:])
                process  = (forkstatEntry.info == 'thread')
            case 'comm':
                forkstatEntry.info     = None
                forkstatEntry.duration = None
                forkstatEntry.command  = ' '.join(items[6:])
                process  = False
            case 'exec':
                forkstatEntry.info     = None
                forkstatEntry.duration = None
                forkstatEntry.command  = ' '.join(items[6:])
                process  = True
            case 'exit':
                forkstatEntry.info     = items[6]
                forkstatEntry.duration = items[7]
                forkstatEntry.command  = ' '.join(items[8:])
                process  = False
            case 'fork':
                forkstatEntry.info     = items[6]
                forkstatEntry.duration = None
                forkstatEntry.command  = ' '.join(items[7:])
                process  = (forkstatEntry.info == 'child')
        if (process):
            process_forkstat_entry(forkstatEntry)
    lock.release()

def process_forkstat_entry(forkstatEntry):
    process_process_entry(
        ProcessEntry(forkstatEntry.pid, forkstatEntry.command)
    )

def process_process_entry(processEntry):
    for rule in config.rules:
        if (re.match(rule.compiled, processEntry.command)):
            print("MATCH:", processEntry)

def main():
    config.read()
    thread = threading.Thread(
        target = scan_whole_tree,
        daemon = True
    )
    thread.start()
    forkstat = subprocess.Popen(
        ['forkstat', '-l', '-x', '-e', 'clone,exec,fork'],
        stdout = subprocess.PIPE
    )
    while (forkstat.poll() == None):
        line = forkstat.stdout.readline().decode('UTF-8').rstrip()
        process_forkstat_line(line)
    sys.exit(1)

if (__name__ == '__main__'):
    main()
