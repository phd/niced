#!/usr/bin/python3

''' niced - a daemon renicing new and existing processes '''

import re
import signal
import subprocess
import sys
import threading
import time

import psutil

CONFIG_PATH                = './nicedrc'
DEFAULT_FULL_SCAN_INTERVAL = '5'

NICE_DEFAULT_PRIORITY    = 10 # see nice(1)
IONICE_CLASS_NONE        = 0  # see ionice(1)
IONICE_CLASS_REALTIME    = 1
IONICE_CLASS_BEST_EFFORT = 2
IONICE_CLASS_IDLE        = 3

# pylint: disable=superfluous-parens

def int_or_none(string):
    try:
        return int(string)
    except:
        return None

class ConfigRule():
    ''' parsed configuration line '''
    # pylint: disable=too-few-public-methods
    match         = None
    regex         = None
    recursive     = None
    nice          = None
    io_class      = None
    io_nice       = None
    oom           = None
    def __str__(self):
        return 'ConfigRule(\n' + \
            f'        match={self.match        }\n' + \
            f'        regex={self.regex.pattern}\n' + \
            f'    recursive={self.recursive    }\n' + \
            f'         nice={self.nice         }\n' + \
            f'     io_class={self.io_class     }\n' + \
            f'      io_nice={self.io_nice      }\n' + \
            f'          oom={self.oom          }\n' + \
            ')'
    @staticmethod
    def from_config_line(line):
        ''' create ConfigRule by parsing given configuration line '''
        rule = ConfigRule()
        line = re.sub('\\s+', ' ', line)
        items = line.split(' ', maxsplit = 1)
        actions_str = items[0]
        actions_str = re.sub('([a-zA-Z])', ',\\1', actions_str)
        actions = actions_str.split(',')
        actions = list(filter(None, actions))
        actions = [[action[0], action[1:]] for action in actions]
        for action in actions:
            match (action[0]):
                case 'R':
                    rule.recursive = int_or_none(action[1]) or 0
                case 'n' | '':
                    rule.nice = int_or_none(action[1]) or NICE_DEFAULT_PRIORITY
                case 'r':
                    rule.io_class = IONICE_CLASS_REALTIME
                    rule.io_nice = int_or_none(action[1])
                case 'b':
                    rule.io_class = IONICE_CLASS_BEST_EFFORT
                    rule.io_nice = int_or_none(action[1])
                case 'i':
                    rule.io_class = IONICE_CLASS_IDLE
                    rule.io_nice = int_or_none(action[1])
                case 'o':
                    rule.oom = int_or_none(action[1])
        rule.match = items[1]
        match = rule.match
        if (not match.startswith('(')):
            match = '(^|[^\\s]*/)(' + match + ')(\\s|$)'
        rule.regex = re.compile(match)
        return rule

class Config():
    ''' config singleton '''
    # pylint: disable=too-few-public-methods
    rules              = []
    full_scan_interval = DEFAULT_FULL_SCAN_INTERVAL
    @staticmethod
    def load():
        ''' method loading configuration from config file '''
        with open(CONFIG_PATH, mode = 'r', encoding = 'utf-8') as config_file:
            for line in config_file:
                line = line.strip()
                if (line[0] == '#'):
                    continue
                if (line[0] == '@'):
                    line = line[1:].strip()
                    items = re.split('\\s*=\\s*', line, maxsplit = 1)
                    setattr(Config, items[0], items[1])
                    continue
                rule = ConfigRule.from_config_line(line)
                Config.rules.append(rule)

class ForkstatEntry():
    ''' parsed process line from forkstat '''
    valid    = False
    time     = None
    event    = None
    pid      = None
    info     = None
    duration = None
    command  = None
    def __str__(self):
        return 'ForkstatEntry(\n' + \
            f'        time={self.time    }\n' + \
            f'       event={self.event   }\n' + \
            f'         pid={self.pid     }\n' + \
            f'        info={self.info    }\n' + \
            f'    duration={self.duration}\n' + \
            f'     command={self.command }\n' + \
            ')'
    @staticmethod
    def from_forkstat_line(line):
        ''' create ForkstatEntry by parsing given process line from forkstat '''
        line = re.sub('\\s+', ' ', line)
        items = line.split(' ')
        forkstat_entry = ForkstatEntry()
        if (not re.match('[0-9]+:[0-9]+:[0-9]+', items[0])):
            return forkstat_entry
        forkstat_entry.valid = False
        forkstat_entry.time  = items[0]
        forkstat_entry.event = items[1]
        forkstat_entry.pid   = items[2]
        match (forkstat_entry.event):
            case 'clone':
                forkstat_entry.info     = items[3]
                forkstat_entry.duration = None
                forkstat_entry.command  = ' '.join(items[4:])
                forkstat_entry.valid  = (forkstat_entry.info == 'thread')
            case 'comm':
                forkstat_entry.info     = None
                forkstat_entry.duration = None
                forkstat_entry.command  = ' '.join(items[3:])
                forkstat_entry.valid  = False
            case 'exec':
                forkstat_entry.info     = None
                forkstat_entry.duration = None
                forkstat_entry.command  = ' '.join(items[3:])
                forkstat_entry.valid  = True
            case 'exit':
                forkstat_entry.info     = items[3]
                forkstat_entry.duration = items[4]
                forkstat_entry.command  = ' '.join(items[5:])
                forkstat_entry.valid  = False
            case 'fork':
                forkstat_entry.info     = items[3]
                forkstat_entry.duration = None
                forkstat_entry.command  = ' '.join(items[4:])
                forkstat_entry.valid  = (forkstat_entry.info == 'child')
        return forkstat_entry

class Forkstat():
    ''' forkstat subprocess '''
    _process = None
    @staticmethod
    def start():
        ''' start forkstat subprocess in the background '''
        # pylint: disable=consider-using-with
        Forkstat._process = subprocess.Popen(
            ['forkstat', '-l', '-e', 'clone,exec,fork'],
            stdout = subprocess.PIPE
        )
    @staticmethod
    def next_entry():
        ''' wait for the next forkstat process line and parse it '''
        if (Forkstat._process is None):
            return None
        if (Forkstat._process.poll() is not None):
            return None
        line = Forkstat._process.stdout.readline().decode('UTF-8').rstrip()
        return ForkstatEntry.from_forkstat_line(line)

class ProcessEntry():
    ''' contains information about a process '''
    pid     = None
    command = None
    def __init__(self, pid = None, command = None):
        self.pid     = pid
        self.command = command
    def __str__(self):
        return 'ProcessEntry(\n' + \
            f'        pid={self.pid    }\n' + \
            f'    command={self.command}\n' + \
            ')'
    @staticmethod
    def from_forkstat_entry(forkstat_entry):
        ''' create ProcessEntry from ForkstatEntry '''
        return ProcessEntry(forkstat_entry.pid, forkstat_entry.command)

class Processor():
    ''' main loop matching and renicing processes '''
    _lock = threading.Lock()
    @staticmethod
    def run():
        ''' run main loop, it exits if forkstat dies '''
        Forkstat.start()
        while True:
            forkstat_entry = Forkstat.next_entry()
            if (forkstat_entry is None):
                break
            if (not forkstat_entry.valid):
                continue
            process_entry = ProcessEntry.from_forkstat_entry(forkstat_entry)
            Processor.handle_process_entry(process_entry)
    @staticmethod
    def handle_process_entry(process_entry):
        ''' match and renice given ProcessEntry '''
        for rule in Config.rules:
            if (re.match(rule.regex, process_entry.command)):
                with Processor._lock:
                    print("MATCH:", process_entry)

class FullScanThread():
    ''' thread periodically scanning full process tree '''
    # pylint: disable=too-few-public-methods
    @staticmethod
    def _scan():
        while (True):
            for process in psutil.process_iter():
                process_entry = ProcessEntry()
                process_entry.pid     = process.pid
                process_entry.command = ' '.join(process.cmdline())
                if (process_entry.pid and process_entry.command):
                    Processor.handle_process_entry(process_entry)
            time.sleep(int(Config.full_scan_interval))
    @staticmethod
    def start():
        ''' start the full-scan thread in the background '''
        thread = threading.Thread(
            target = FullScanThread._scan,
            daemon = True
        )
        thread.start()

def sig_exit(sig, frame):
    ''' exit on received signal '''
    del sig, frame
    print("Exiting...")
    sys.exit(0)

def main():
    ''' main entry point '''
    signal.signal(signal.SIGINT,  sig_exit)
    signal.signal(signal.SIGTERM, sig_exit)
    signal.signal(signal.SIGCONT, sig_exit)
    Config.load()
    FullScanThread.start()
    Processor.run() # main loop
    sys.exit(1)

if (__name__ == '__main__'):
    main()
